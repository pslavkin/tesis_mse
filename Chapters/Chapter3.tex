\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3}

En este capítulo se desglosan los bloques principales del sistema, se explica su interconexion, los criterios de diseño y los aspectos mas relevantes de cada implementación.

\section{Diseño general del sistema}

En los diagramas de bloques de la figura \ref{fig:system_blocks} se realiza la comparacion entre el sistema de conexionado original, figura \ref{fig:system_blocks0}, y modificado para el reconocimiento de marcas, figura \ref{fig:system_blocks1}.

\subfigab 
         {0.45} {system_blocks0.pdf} {Diagrama de bloques del sistema original de interconexion entre la maquina CNC y el controlador NK105 sin ninguna intervencion.} {fig:system_blocks0}
         {0.45}{system_blocks1.pdf} {Diagrama de bloques del sistema de interconexion de la maquina CNC con los bloques implementados para el reconocimiento de marcas.} {fig:system_blocks1}
         {Comparacion entre la interconexion original de la maquina CNC y luego de agregar el sistema de reconocimiento de marcas}
         {fig:system_blocks}

         En la siguiente lista se detallan las principales características de cada bloque:
         \begin{itemize}
            \item{Wi-Fi: es una red inalámbrica compartida entre los bloques ``PocketBeagle'', ``Cámara de video'' y ``Navegador web''. No requiere tener acceso a internet.}
            \item{Navegador web: se refiere a cualquier dispositivo que pueda ejecutar un navegador: ordenador personal, teléfono celular, tableta, etc.}
            \item{PocketBeagle: es la plataforma de desarrollo PocketBeagle con el agregado de una circuitería que permite intercalarse entre los bloques ``Controlador CNC'' y ``Mando a distancia''}
            \item{Maquina CNC: es el conjunto de piezas electromecánicas motorizadas para el realizar el mecanizado de piezas.}
            \item{Controlador CNC: es el dispositivo electrónico encargado de comandar los motores de la maquina CNC para generar los movimientos de corte.}
            \item{Mando a distancia: es un dispositivo electrónico cableado que se conecta al ``Controlador CNC'' y cuenta con una pantalla para visualización y un teclado para interacción con el operador de la maquina.}
            \item{Cámara de video: es el dispositivo que se monta en la maquina CNC y permite capturar las imágenes que se utilizaran para el reconocimiento de marcas. En esta implementación se utiliza la cámara de un teléfono celular, pero podría ser otra mientras permita la transmisión de video por el protocolo IP.}
         \end{itemize}


\section{Bloque PocketBeagle}

   El controlador elegido para este trabajo es muy popular y su buen desempeño es reconocido en la industria, pero no ofrece ninguna opción de interconexión excepto su mando a distancia a traves de un cable multifilar.\par

   Se estudio en detalle este cable que conecta el ``Controlador CNC'' con su ``Mando a distancia'' y se determino que tiene dos canales de comunicación, una comunicación serial UART \textit{universal asynchronous receiver-transmitter} que comunica periódicamente el estado del teclado y una interfaz SPI \textit{synchronous peripheral interface} sobre la cual se envían los datos a la pantalla LCD. \par

   Para poder interactuar con estas interfases se intercaló una tarjeta electronica que las conecta a la plataforma PocketBeagle como se muestra en la figura \ref{fig:handheld_a_pocket} .\par

\subfigab 
{0.48} {handheld_a_pocket_original} { ``Controlador CNC'' conectado con su ``Mando a distancia'' sin intervencion.\\ \vphantom{1}}{handheld_a_pocket_original}
{0.48} {handheld_a_pocket_intervenido} {``Controlador CNC'' conectado con su ``Mando a distancia'' intervenido por la\\ ``PocketBeagle''.}{handheld_a_pocket_intervenido}
   {Comparacion entre la conexion del controlador y su comando antes y despues de ser intervenido por el accesorio desarrollado.}
   {fig:handheld_a_pocket}

         Como la conexión entre el ``Mando a distancia'' y el ``Controlador NK105'' se realiza con un conector, el proceso de intercalar ``PocketBeagle'' es un proceso reversible, no modifica la funcionalidad original del sistema y permite instalarse sin dificultades.\par

   Se desarrollaron una serie de aplicaciones de software que se muestran en la figura \ref{fig:system_blocks2} para lograr dos objetivos principales que se detallan en las subsecciones siguientes

\subfiga {0.8}
         {system_blocks2.pdf}
         {Diagrama de bloques del sistema implementado con el objeto de identificar las tecnologías involucradas en cada bloque.}
         {fig:system_blocks2}

\subsection{Teclado virtual}

      Para lograr enviar datos desde la PocketBeagle al controlador se desarrollo una aplicación en lenguaje C que corre como servicio en la PocketBeagl.\par
      En el fragmento de código \ref{cod:handheld1} se pueden ver tres tareas o \textit{threads} que implementan la lectura del teclado físico, la lectura de una cola virtual, el intercalado y el envió de los datos al controlador.\par

\begin{lstlisting}[label=cod:handheld1,caption=Funcion de intercalado de datos entre el teclado fisico y el virtual utilizando colas.]

//recibe los datos desde el teclado fisico por interfase serial
void* rcvFunc(void* niyto)
{
   char frame[FRAME_SIZE];
   while(true) {
      while ( Get_Byte(PORT_NUMBER, frame )<1 || frame[0]!=FRAME_HEADER)
         ;
      PollComport(PORT_NUMBER, frame+1, FRAME_SIZE-1);
      if(memcmp(frame,FRAME_DEFAULT,FRAME_SIZE))
         mq_send(msgQueue,frame,FRAME_SIZE,1);
   }
}
//recibe los datos a traves de una cola del sistema operativo
void* rcvVirtual(void* niyto)
{
   char buf  [ MAX_VIRTUAL_CMD_LENGHT ];
   char frame[ FRAME_SIZE             ];
   FILE* pipeVi;
   while(pipeVi=fopen(PIPE_VI,"r")) {
      while(fgets(buf,MAX_VIRTUAL_CMD_LENGHT,pipeVi)>0) {
         memcpy(frame,FRAME_DEFAULT,FRAME_SIZE);
         mapBtn2Bits(atoi(buf),frame);
         crc(frame);
         if(memcmp(frame,FRAME_DEFAULT,FRAME_SIZE)) {
            mq_send(msgQueue,frame,FRAME_SIZE,1);
         }
      }
      fclose(pipeVi);
   }
}
//intercala los datos del teclado fisico y el virtual y envia la salida al controlador 
void* sendFunc(void* niyto)
{
   struct timespec tm;
   char frame[ FRAME_SIZE ];
   while ( true ) {
      clock_gettime(CLOCK_REALTIME, &tm);
      tm=timespec_add (tm,(struct timespec){0, QUEUE_SND_TOUT});
      mq_timedreceive( msgQueue,frame,FRAME_SIZE,NULL,&tm);
      sendBuf        ( PORT_NUMBER  ,ans?frame:FRAME_DEFAULT ,FRAME_SIZE );
   }
}
\end{lstlisting}

   Se aprovecharon los mecanismos de colas o FIFO's \textit{names pipes} por sus siglas en inglés, que ofrece Linux para multiplexar los datos del ``Teclado'' con un nuevo bloque ``Teclado virtual''.\par
      Con esta tecnica, si se envian datos a la ``FIFO Rx'' los datos se envian al controlador emulando el presionado de un boton en el teclado fisico, pero al mismo tiempo se atiende la comunicacion original y el controlador se puede manejar virtual o fisicamente.
      
\subsection{Pantalla virtual}

      Para poder conocer el estado del controlador es necesario contar con la informacion que se muestra en la pantalla LCD. 
      Se estudio en detalle las especificaciones del controlador de esta pantalla y debido a la alta velocidad de los datos y que las tramas no estan definidas ni en tiempo ni en el largo de las tramas, no fue posible leer esta informacion con una aplicacion en espacio de usuario. \par
      Para poder recolectarlos se implemento un driver SPI en modo exclavo \textit{spi slave} como modulo del kernel del sistema operativo.
      Este driver, a diferencia del driver original del kernel, permite recibir cualquier longitud de trama y en cualquier momento y almacenarla en una memoria contigua.
      Esto se logro utliazando las siguientes tecnicas:
      \begin{itemize}
         \item {Interrupciones: Se utilizo una interrupcion conectada a la senal de seleccion de chip del SPI \textit{chip select}. Esto permite reaccionar rapidamente cuando se inicia una transaccion.}
         \item {Acceso directo a memoria: Se utilizo el susbsistema DMA \textit{direct access memory} para que las operaciones de copia de los datos que se reciben por SPI a mamoria las realice un bloque de hardware sin la intervencion del procesador. Esto permite conservar los recursos del procesador para otras tareas.}
         \item{Comunicacion interprocessos: Se utilizaron diversos metodos de IPC's \textit{interprocess commnications} que ofrece Linux para lograr un sistema reactivo con minimo retardo.}
         \item{Operaciones de archivo: Para la salida de los datos se utiliza el acceso estandard del sistema como si este fuera un archivo. De esta manera se aprovechan las herramientas estandars de lectura del sistema operativo y se facilita la integracion con el software en espacio de usuario.}
         \item{multitarea de kernel: dentro del modulo se utilizaron varias tareas \textit{kthreads} para evitar bloqueos entre operaciones de escritura de datos al espacio de usuario con la recepcion de nuevos datos por SPI}
      \end{itemize}

      En el diagrama de bloques de la figura \ref{fig:lcd_driver_blocks} se muestra la secuencia de pasos que se implemento dentro del modulo. 
      
\subfiga {1}
         {lcd_driver_blocks.pdf}
         {Diagrama de bloques implementados en el driver de kernel para la lectura e interpretacion de las tramas del LCD.}
         {fig:lcd_driver_blocks}

      %,caption=Fragmentos de codigo del modulo implementado para recibir y procesar las tramas de datos del LCD.]
         \begin{lstlisting}[caption={Fragmentos de codigo del modulo implementado para recibir y procesar las tramas de datos del LCD.},label={cod:lcd_driver}]
//Manejador de interrupcion conectada a la senal de chip select
static irq_handler_t csIrqHandler(unsigned int irq, void *dev_id, struct pt_regs *regs)
{
   complete(getNewDataReady());
   printkk(KERN_DEBUG "llego irq %i\r\n",irqCounter++);
   setGpio();
   return (irq_handler_t) IRQ_HANDLED;
}
\end{lstlisting}

\begin{lstlisting}[caption={},label={cod:lcd_driver},title={\lstlistingname~\thelstlisting: Fragmentos de codigo del modulo implementado para recibir y procesar las tramas de datos del LCD. (continued)}] 

//espera una trama y la procesa
static int newDataFunc(void *nol)
{
   int ans;
   while(1) {
      ans=wait_for_completion_interruptible_timeout(&newData.ready,msecs_to_jiffies(param_newDataTout));
      reinit_completion(&newData.ready);
      newData.actualIndex = findSpiFifoLen(newData.actualIndex);
      newData.lastIndex = parse ( newData.actualIndex);
      if(ans==0)
         wakeUpFileOp();
   }
   return 0;
}
\end{lstlisting}

\begin{lstlisting}[name={caption},caption={},label=cod:lcd_driver,title={\lstlistingname~\thelstlisting: Fragmentos de codigo del modulo implementado para recibir y procesar las tramas de datos del LCD. (continued)}] 

//esta funcion se llama cuando desde el espacio de usuario se pide un acceso de lectura
static ssize_t lcd_read( struct file *filp, char __user *buf, size_t count, loff_t *f_pos )
{
   size_t len=0;
   size_t miss=0;
   char localBuf[FRAME_LEN];

   int i=(int)filp->private_data;
   wait_event_interruptible(fileOp.queue[i].ready, fileOp.queue[i].flag);
   fileOp.queue[i].flag=false;
   len  = ((FRAME_LEN-1)<count)?(FRAME_LEN-1):count;
   memcpy(localBuf,(char*)getLcd()->cdram,LCD_LEN);
   snprintf(localBuf+LCD_LEN,TRAILER_LEN,"%05u\r\n",fileOp.queue[i].frameNumber++);
   miss= copy_to_user(buf,localBuf,FRAME_LEN-1);
   len=len-miss;
   decWakeUpCounter();
   return len;
};


\end{lstlisting}


      En la foto de la figura \ref{fig:handheld_lcd_on_action} se puede ver en la pantalla del ``Mando a distancia'' una operacion de ingreso los numeros ``1234'' sin presionar los botones del teclado fiscio sino que se enviaron desde una consola de comandos de la PocketBeagle.\par

\subfiga {1}
         {handheld_lcd_on_action}
         {Virtualizacion completa del teclado y LCD utilizando la PocketBeagle. Se envian datos a una FIFO que son leidos por un servicio que los redirecciona al controlador. Los datos del LCD son capturados por el el driver de kernel y mostrados en la consola. Se puede ver la sincronia entre el mando a distancia y el virutal.}
         {fig:handheld_lcd_on_action}



LLEGUE HASTA ACA \ldots.

   \subsection{Camara de video a PocketBeagle}
   \subsection{USB cliente mass storage a NK105}

\section{Kernel de Linux y file system}
   \subsection{Adaptacion del devicetree para PocketBeagle}
   \subsection{Manejador de dispositivo SPI esclavo}
   \subsection{Decodificacion de comandos del LCD}
\section{Aplicación de captura de teclado}
\subsection{Aplicación de rotación y escala de GCode}
\subsection{Algoritmos para reconocimiento de marcas}

\subsection{Intervencion al NK105}

\section{Intervencion al NK105}

\subfigab
         %{intervencion_mando_uart}{intervencion_mando_spi}
   {0.45}{no_signal}{comentario}{fig:intervencion_mando_A}
   {0.45}{no_signal}{comentario}{fig:intervencion_mando_B}
         {Mando a distancia del controlador NK105 a) Cominicacion por UART del estado de la botonera b) Envío de datos del controlador al LCD por SPI}
         {fig:intervencion_mando}


\section{Envio de arvhivos por USB}

\subfigtwotwo
         {0.48}{nkhack1.png} {comentario}
         {0.48}{nkhack2.png} {comentario}
         {0.48}{nkhack3.png} {comentario}
         {0.48}{nkhack3.png} {comentario}
         {Aplicacion web desarrollada para controlar la maquina, transferir archivos, gestionar la deteccion de marcas, visualizar el trabajo a cortar en tiempo real, entre otras utilidades de configuracion.}
         {fig:nkhack}
