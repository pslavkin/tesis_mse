\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3}

En este capítulo se desglosan los bloques principales del sistema, se explica su interconexion, los criterios de diseño y los aspectos mas relevantes de cada implementación.

\section{Diseño general del sistema}

En los diagramas de bloques de la figura \ref{fig:system_blocks} se realiza la comparacion entre el sistema de conexionado original, figura \ref{fig:system_blocks0}, y modificado para el reconocimiento de marcas, figura \ref{fig:system_blocks1}.

\subfigab 
        {0.45} {system_blocks0.pdf} {Diagrama de bloques del sistema original de interconexion entre la maquina CNC y el controlador NK105 sin ninguna intervencion.} {fig:system_blocks0}
        {0.45}{system_blocks1.pdf} {Diagrama de bloques del sistema de interconexion de la maquina CNC con los bloques implementados para el reconocimiento de marcas.} {fig:system_blocks1}
        {Comparacion entre la interconexion original de la maquina CNC y luego de agregar el sistema de reconocimiento de marcas}
        {fig:system_blocks}

         En la siguiente lista se detallan las principales características de cada bloque:
         \begin{itemize}
            \item{Wi-Fi: es una red inalámbrica compartida entre los bloques ``PocketBeagle'', ``Cámara de video'' y ``Navegador web''. No requiere tener acceso a internet.}
            \item{Navegador web: se refiere a cualquier dispositivo que pueda ejecutar un navegador: ordenador personal, teléfono celular, tableta, etc.}
            \item{PocketBeagle: es la plataforma de desarrollo PocketBeagle con el agregado de una circuitería que permite intercalarse entre los bloques ``Controlador CNC'' y ``Mando a distancia''}
            \item{Maquina CNC: es el conjunto de piezas electromecánicas motorizadas para el realizar el mecanizado de piezas.}
            \item{Controlador CNC: es el dispositivo electrónico encargado de comandar los motores de la maquina CNC para generar los movimientos de corte.}
            \item{Mando a distancia: es un dispositivo electrónico cableado que se conecta al ``Controlador CNC'' y cuenta con una pantalla para visualización y un teclado para interacción con el operador de la maquina.}
            \item{Cámara de video: es el dispositivo que se monta en la maquina CNC y permite capturar las imágenes que se utilizaran para el reconocimiento de marcas. En esta implementación se utiliza la cámara de un teléfono celular, pero podría ser otra mientras permita la transmisión de video por el protocolo IP.}
         \end{itemize}


\section{Bloque PocketBeagle}

   El controlador elegido para este trabajo es muy popular y su buen desempeño es reconocido en la industria, pero no ofrece ninguna opción de interconexión excepto su mando a distancia a traves de un cable multifilar.\par

   Se estudio en detalle este cable que conecta el ``Controlador CNC'' con su ``Mando a distancia'' y se determino que tiene dos canales de comunicación, una comunicación serial UART \textit{universal asynchronous receiver-transmitter} que comunica periódicamente el estado del teclado y una interfaz SPI \textit{synchronous peripheral interface} sobre la cual se envían los datos a la pantalla LCD. \par

   Para poder interactuar con estas interfases se intercaló una tarjeta electronica que las conecta a la plataforma PocketBeagle como se muestra en la figura \ref{fig:handheld_a_pocket} .\par

\subfigab 
   {0.48} {handheld_a_pocket_original} { ``Controlador CNC'' conectado con su ``Mando a distancia'' sin intervencion.\\ \vphantom{1}}{handheld_a_pocket_original}
   {0.48} {handheld_a_pocket_intervenido} {``Controlador CNC'' conectado con su ``Mando a distancia'' intervenido por la\\ ``PocketBeagle''.}{handheld_a_pocket_intervenido}
   {Comparacion entre la conexion del controlador y su comando antes y despues de ser intervenido por el accesorio desarrollado.}
   {fig:handheld_a_pocket}

         Como la conexión entre el ``Mando a distancia'' y el ``Controlador NK105'' se realiza con un conector, el proceso de intercalar ``PocketBeagle'' es un proceso reversible, no modifica la funcionalidad original del sistema y permite instalarse sin dificultades.\par

   Se desarrollaron una serie de aplicaciones de software que se muestran en la figura \ref{fig:system_blocks2} para lograr dos objetivos principales que se detallan en las subsecciones siguientes

\subfiga {0.8}
         {system_blocks2.pdf}
         {Diagrama de bloques del sistema implementado con el objeto de identificar las tecnologías involucradas en cada bloque.}
         {fig:system_blocks2}

\subsection{Teclado virtual}

      Para lograr enviar datos desde la PocketBeagle al controlador se desarrollo una aplicación en lenguaje C que corre como servicio en la PocketBeagl.\par
      En el fragmento de código \ref{cod:handheld1} se pueden ver tres tareas o \textit{threads} que implementan la lectura del teclado físico, la lectura de una cola virtual, el intercalado y el envió de los datos al controlador.\par

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={Tarea encargada de procesar los datos del teclado fisico y reenviarlos a la cola de multiplexado.}]

   void* rcvFunc(void* niyto)
   {
      char frame[FRAME_SIZE];
      while(true) {
         while ( Get_Byte(PORT_NUMBER, frame )<1 || frame[0]!=FRAME_HEADER)
            ;
         PollComport(PORT_NUMBER, frame+1, FRAME_SIZE-1);
         if(memcmp(frame,FRAME_DEFAULT,FRAME_SIZE))
            mq_send(msgQueue,frame,FRAME_SIZE,1);
      }
   }
   \end{lstlisting}
\end{figure}

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={},title={\lstlistingname~\thelstlisting:Tarea que recibe datos del teclado virtual y los reenvia a la cola de multiplexado..}]
   void* rcvVirtual(void* niyto)
   {
      char buf  [ MAX_VIRTUAL_CMD_LENGHT ];
      char frame[ FRAME_SIZE             ];
      FILE* pipeVi;
      while(pipeVi=fopen(PIPE_VI,"r")) {
         while(fgets(buf,MAX_VIRTUAL_CMD_LENGHT,pipeVi)>0) {
            memcpy(frame,FRAME_DEFAULT,FRAME_SIZE);
            mapBtn2Bits(atoi(buf),frame);
            crc(frame);
            if(memcmp(frame,FRAME_DEFAULT,FRAME_SIZE)) {
               mq_send(msgQueue,frame,FRAME_SIZE,1);
            }
         }
         fclose(pipeVi);
      }
   }
   \end{lstlisting}
\end{figure}

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={},title={\lstlistingname~\thelstlisting:Taread de multiplexado de los datos del teclado fisico y virtual.}]
   void* sendFunc(void* niyto)
   {
      struct timespec tm;
      char frame[ FRAME_SIZE ];
      while ( true ) {
         clock_gettime(CLOCK_REALTIME, &tm);
         tm=timespec_add (tm,(struct timespec){0, QUEUE_SND_TOUT});
         mq_timedreceive( msgQueue,frame,FRAME_SIZE,NULL,&tm);
         sendBuf        ( PORT_NUMBER  ,ans?frame:FRAME_DEFAULT ,FRAME_SIZE );
      }
   }
   \end{lstlisting}
\end{figure}

   Se aprovecharon los mecanismos de colas o FIFO's \textit{names pipes} por sus siglas en inglés, que ofrece Linux para multiplexar los datos del ``Teclado'' con un nuevo bloque ``Teclado virtual''.\par
      Con esta tecnica, si se envian datos a la ``FIFO Rx'' los datos se envian al controlador emulando el presionado de un boton en el teclado fisico, pero al mismo tiempo se atiende la comunicacion original y el controlador se puede manejar virtual o fisicamente.\par
   Dado que la recepcion es a traves de una FIFO, es posible instanciar mas de un teclado virtual con accesos concurrentes \citep{book:embeddedprimer}.

\subsection{Pantalla virtual}

      Para poder conocer el estado del controlador es necesario contar con la informacion que se muestra en la pantalla LCD.\par
      Se estudio en detalle las especificaciones del controlador de esta pantalla y debido a la alta velocidad de los datos y que las tramas no estan definidas ni en tiempo ni en el largo de las tramas, no fue posible leer esta informacion con una aplicacion en espacio de usuario. \par
      Para poder recolectarlos se implemento un driver SPI en modo exclavo \textit{spi slave} como modulo del kernel del sistema operativo \citep{book:ldd3}.
      Este driver, a diferencia del driver original del kernel, permite recibir cualquier longitud de trama y en cualquier momento y almacenarla en una memoria contigua.
      Esto se logro utliazando las siguientes tecnicas:
      \begin{itemize}
         \item {Interrupciones: Se utilizo una interrupcion conectada a la senal de seleccion de chip del SPI \textit{chip select}. Esto permite reaccionar rapidamente cuando se inicia una transaccion.}
         \item {Acceso directo a memoria: Se utilizo el susbsistema DMA \textit{direct access memory} para que las operaciones de copia de los datos que se reciben por SPI a mamoria las realice un bloque de hardware sin la intervencion del procesador. Esto permite conservar los recursos del procesador para otras tareas.}
         \item{Comunicacion interprocessos: Se utilizaron diversos metodos de IPC's \textit{interprocess commnications} que ofrece Linux para lograr un sistema reactivo con minimo retardo.}
         \item{Operaciones de archivo: Para la salida de los datos se utiliza el acceso estandard del sistema como si este fuera un archivo. De esta manera se aprovechan las herramientas estandars de lectura del sistema operativo y se facilita la integracion con el software en espacio de usuario.}
         \item{multitarea de kernel: dentro del modulo se utilizaron varias tareas \textit{kthreads} para evitar bloqueos entre operaciones de escritura de datos al espacio de usuario con la recepcion de nuevos datos por SPI}
      \end{itemize}

      En el diagrama de bloques de la figura \ref{fig:lcd_driver_blocks} se muestra la secuencia de pasos que se implemento dentro del modulo. 
      
\subfiga {0.7}
         {lcd_driver_blocks.pdf}
         {Diagrama de bloques implementados en el driver de kernel para la lectura e interpretacion de las tramas del LCD.}
         {fig:lcd_driver_blocks}

\begin{figure}[h]
   \begin{lstlisting}[caption={Manejador de la interrupcion asociada auna transaccion SPI. Cuando es llamada activa toda la cadena de procesos que actualiza el estado de la pantalla.},label={cod:lcd_driver}]
   static irq_handler_t csIrqHandler(unsigned int irq, void *dev_id, struct pt_regs *regs)
   {
      complete(getNewDataReady());
      return (irq_handler_t) IRQ_HANDLED;
   }
   \end{lstlisting}
\end{figure}

\begin{figure}[h]
   \begin{lstlisting}[caption={},label={cod:lcd_driver},title={\lstlistingname~\thelstlisting: Tarea que espera en modo bloqueante una trama nueva. Utiliza uno de los metodos de comunicacion interprocesos del kernel de Linux.}]

   static int newDataFunc(void *nol)
   {
      int ans;
      while(1) {
         ans=wait_for_completion_interruptible_timeout(&newData.ready,msecs_to_jiffies(param_newDataTout));
         reinit_completion(&newData.ready);
         newData.actualIndex = findSpiFifoLen(newData.actualIndex);
         newData.lastIndex = parse ( newData.actualIndex);
         if(ans==0)
            wakeUpFileOp();
      }
      return 0;
   }
   \end{lstlisting}
\end{figure}

\begin{figure}[h]
   \begin{lstlisting}[name={caption},caption={},label=cod:lcd_driver,title={\lstlistingname~\thelstlisting: Funcion que bloquea a la espera de una operacion de lectura del espacio de usuario. Cuando se activa copia el estado de la pantalla.}] 

   static ssize_t lcd_read( struct file *filp, char __user *buf, size_t count, loff_t *f_pos )
   {
      size_t len=0;
      size_t miss=0;
      char localBuf[FRAME_LEN];

      int i=(int)filp->private_data;
      wait_event_interruptible(fileOp.queue[i].ready, fileOp.queue[i].flag);
      fileOp.queue[i].flag=false;
      len  = ((FRAME_LEN-1)<count)?(FRAME_LEN-1):count;
      memcpy(localBuf,(char*)getLcd()->cdram,LCD_LEN);
      snprintf(localBuf+LCD_LEN,TRAILER_LEN,"%05u\r\n",fileOp.queue[i].frameNumber++);
      miss= copy_to_user(buf,localBuf,FRAME_LEN-1);
      len=len-miss;
      decWakeUpCounter();
      return len;
   };
   \end{lstlisting}
\end{figure}

\subsection{Sistema virtual completo}
      En conjunto los dos susbsistemas, el teclado virutal corriendo como servicio del sistema operativo para manajar la UART y la pantalla virtual corriendo como modulo del kernel asociadodo a la interfaz SPI, son todo lo necesario para tomar control de la maquina desde la PocketBeagle.\par
      En la foto de la figura \ref{fig:handheld_lcd_on_action} se puede ver en la pantalla del ``Mando a distancia'' una operacion de ejemplo en la cual se ingresan los numeros ``1234'' sin presionar los botones del teclado fisico sino que se envian desde una consola de comandos de la PocketBeagle.\par
      Dada lo compelidad y la falta de informacion oficial, el desarrollo y puesta a punto de estos dos subsistemas representaron aproximadamente el 50\% del desaroollo total de este trabajo.\par

\subfiga {1}
         {handheld_lcd_on_action}
         {Virtualizacion completa del teclado y LCD utilizando la PocketBeagle. Se envian datos a una FIFO que son leidos por un servicio que los redirecciona al controlador. Los datos del LCD son capturados por el el driver de kernel y mostrados en la consola. Se puede ver la sincronia entre el mando a distancia y el virutal.}
         {fig:handheld_lcd_on_action}


\subsection{Conextion USB como almacenamiento masivo}
   Otro de los inconvenientes del controlador es que la unica manera para transferirle archivos es a traves de la conexion por USB de un dispositivo de almacenamiento masivo.\par
   Dado que la PocketBeagle cuenta con una conexion USB que puede actuar como un dispositivo de almacenamiento masivo virtual, se desarrollo una tecnica para intercambiar archivos con el controlador de manera remota a traves de Wi-Fi. \par
   La tecnologia involucrada en Linux para permitir este funcionamiento es \textit{configFS}\citep{WEBSITE:configfs}.\par.
   Se implemento un sistema de doble sistema de archivos como el que se muestra en la figura \ref{fig:configfs}.

\subfigab 
   {0.48} {configfs1} {El controlador lee nuevos archivos del sistema de archivos 1 en verde. La aplicacion escribe futuros trabajos en el sistema de archivos 2 en rojo.}{fig:configfs1}
   {0.48} {configfs2} {El controlador lee nuevos archivos del sistema de archivos 2 en rojo. La aplicacion escribe futuros trabajos en el sistema de archivos 1 en verde.}{fig:configfs2}
   {Sistema de doble sistema de archivos. El verde se presenta al controlador como un dispositivo de almacenamiento masivo con archivos para su ejecucion. Al mismo tiempo el rojo se presenta a la aplicacion web como un sistema de archivos para escribir archivos de futuros trabajos.}
   {fig:configfs}

   En el script mostrado en \ref{cod:configfs} se aprovecha el lenguaje \textit{bash} para implementar este sistema dual en muy pocas lineas.\par
   Este script corre como servicio en la PocketBeagl.

\begin{figure}[h]
   \begin{lstlisting}[language=bash,caption={Implementacion de doble sistema de archivos conectado con la tecnologia configFS. Se aprovecha la potencia del lenguaje de scripting y se corre como servicio.},label={cod:configfs}]

   pipe=./mass_pipe
   mnt_point=./mnt_point
   lun_file=/sys/kernel/config/usb_gadget/g_multi/functions/mass_storage.usb0/lun.0/file
   fs0=./fs0.img
   fs1=./fs1.img

   while true
   do
       if read line <$pipe; then
           if  test $fs = $fs0
           then
              fs=$fs1
           else
              fs=$fs0
           fi
           mount $fs $mnt_point
           cp  $line $mnt_point
           umount $mnt_point
           echo $fs > $lun_file
       fi
   done
   \end{lstlisting}
\end{figure}


\section{Camara de video a PocketBeagle}
Como se comento en la seccion \ref{subsection:camara_de_video}, en el alcance de este trabajo se opto por usar la camara de un telefono celular montado en la maquina CNC y transmitir video por Wi-Fi con una apliacion.\par
   En la fifura \ref{fig:soporte_celu1} se muestra un soporte desarrollado para sujetar el telefono solidario al eje Z de la maquina.\par
   El dispositivo de sujecion permite ajustar la altura y rotacion facilitando el ajuste preciso.\par

\subfiga 
      {0.48} 
      {soporte_celu1}
      {Soporte de telefono implementado, con posibilidad de ajustar la altura, rotacion e inclinacion }
      {fig:soporte_celu1}

   Para recibir las tramas de video desde el celular y posteriormente procesarlas en la PocketBeagle, se implemento una serie de funciones en lenguaje Python sobre la base de la biblioteca PyOpenCV. \par
   En el fragmento de codigo \ref{cod:reconocimiento1} se lista el el procedimiento para acceder a la camara y tomar un fotograma de video.\par

\begin{figure}[h]
   \begin{lstlisting}[language=python,caption={Conexion a la camara del telefono por Wi-Fi y captura de un fotograma para su posterior procesamiento.},label={cod:reconocimiento1}]
   def capture():
      vcap      = cv.VideoCapture("192.168.1.30:/video",cv.CAP_FFMPEG);
      ret       = vcap.grab()
      ret,frame = vcap.retrieve()
      vcap.release()
      return frame
   \end{lstlisting}
\end{figure}

Una vez capturado el fotograma se lo procesa con una secuencia de operaciones que se muestran en el fragmento \ref{cod:reconocimiento2}.

\begin{figure}[h]
   \begin{lstlisting}[language=python,caption={Algoritmo principal de reconocimiento de marcas en un fotograma},label={cod:reconocimiento2}]
def recognition(self,img):
      imgray              = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
      ret, thresh         = cv.threshold(imgray, int(self.grayThresh), 0xff, cv.THRESH_BINARY_INV)
      contours, hierarchy = cv.findContours(thresh, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)

      validContours         = 0
      maxArea               = 0
      maxAreaIndex          = 0
      maxHull               = 0
      maxRect               = 0
      height,width,channels = img.shape

      for i in range ( min(len(contours),10)):
          hull = cv.approxPolyDP(contours[i],0,True) 
          rect = cv.minAreaRect ( hull )
          area = rect[1][0]*rect[1][1]
          if ( area<targetArea*1.5 and area>targetArea*0.5 ):
              if ( area>=maxArea ):
                  maxArea      = area;
                  maxAreaIndex = i;
                  maxHull      = hull
                  maxRect      = rect
          center     = maxRect[0]
          self.angle = maxRect[2]
   \end{lstlisting}
\end{figure}

En la linea 2 del algoritmo se convierte el formato del fotograma ``img'' de tres canales azul, verde y rojo, BGR \textit{blue,green,red} de 8bits por pixel por canal, a un formato en escala de grises de 8bits por pixel segun la ecuacion \ref{eq:bgr2gray}:
\begin{equation}
   \text{RGB[A] to Gray:} \quad Y \leftarrow 0.299 \cdot R + 0.587 \cdot G + 0.114 \cdot B
   \label{eq:bgr2gray}
\end{equation}

  Luego en la linea 3 se convierte el formato de escala de grises a binaria de 8bits, en donde el criterio de seleccion por 0 o 255 lo decide la variable grayThresh.
  Un ejemplo de esta secuencia de procesamiento se puede ver en la figura \ref{fig:reconocimiento_paso_a_paso1}.

\subfigabc
         {0.3}{reconocimiento_paso_a_paso1} {imagen original en color BGR}{fig:reconocimiento_paso_a_paso1a}
         {0.3}{reconocimiento_paso_a_paso2} {imagen escala de grises}{fig:reconocimiento_paso_a_paso1b}
         {0.3}{reconocimiento_paso_a_paso3} {imagen binaria}{fig:reconocimiento_paso_a_paso1c}
         {Imagen original, escala de grises y binaria.}
         {fig:reconocimiento_paso_a_paso1}

         La imagen binaria es procesada en la linea 4 por la funcion ``findContours'' \footnote\opencvfindcontours ,que busca todos los posibles contornos pero esta paramatrizada par que devuela solo aquellos que no estan encerrados por un contorno mallor. De esta manera por ejemplo en el contorno del cuadrado sin relleno solo se muestra el contorno externo. \par
   En la siguiente parte del algortimo se recorren todos los contornos encontrados y se le aplica una funcion que aproxima cada contorno a uno mas suavizado, en donde se filtran las irregularidades de la marca y se parametriza para que devuelva siempre un perimetro cerrado.\par
   Luego a este perimetro se lo encierra con un rectangulo de area minima utilizando la funcion minAreaRect de la linea 15. Esto permite ahora calcular una buena aproximacion del area del perimetro y del angulo.\par
   Con esta informacion se selecciona solamente el perimetro que tenga una area cercana a la especificada por el parametro ``targetArea''. Esto permite discriminar una marca por sobre otras.\par
   Finalmente a la marca elegida se le calcula el desplazamiento en X e Y y su rotacion respecto a la camara. Estos son los datos que se ingresan en las ecuaciones trigonometicas vistas en la seccion \ref{subsection:trigonometria} y es lo que mermite realizar la alineacion de la pieza.
  La secuencia de pasos mencionada se puede ver en la figura \ref{fig:reconocimiento_paso_a_paso2}.

\subfigabc
         {0.3}{reconocimiento_paso_a_paso4} {imagen binaria con todos los permiteros encontrados}{fig:reconocimiento_paso_a_paso2a}
         {0.3}{reconocimiento_paso_a_paso5} {imagen con los perimetros encerrados por rectangulos de ariea minima}{fig:reconocimiento_paso_a_paso2b}
         {0.3}{reconocimiento_paso_a_paso6} {Discriminacion de la marca deseada utilizando el area como selector}{fig:reconocimiento_paso_a_paso2c}
         {Imagen original, escala de grises y binaria.}
         {fig:reconocimiento_paso_a_paso2}

         En el apendice \ref{AppendixA} se presentan varias capturas de marcas mas complejas en donde se visualizan todos los pasos del algoritmo. 

\subfigab
         {0.48}{reconocimiento_comparativa3} {comentario}{fig:reconocimiento_compartiva3}
         {0.48}{reconocimiento_comparativa2} {comentario}{fig:reconocimiento_compartiva2}
         {Comparativa.}
         {fig:reconocimiento_comparativa}

\subfigtwotwo
         {0.48}{reconocimiento_comparativa1} {comentario}
         {0.48}{reconocimiento_comparativa4} {comentario}
         {0.48}{reconocimiento_comparativa5} {comentario}
         {0.48}{reconocimiento_comparativa6} {comentario}
         {Comparativa.}
         {fig:reconocimiento_comparativa}

\section{Kernel de Linux y file system}
   \subsection{Adaptacion del devicetree para PocketBeagle}
\subsection{Aplicación de rotación y escala de GCode}
\subsection{Algoritmos para reconocimiento de marcas}

\subsection{Intervencion al NK105}

\section{Intervencion al NK105}

\subfigab
         %{intervencion_mando_uart}{intervencion_mando_spi}
   {0.45}{no_signal}{comentario}{fig:intervencion_mando_A}
   {0.45}{no_signal}{comentario}{fig:intervencion_mando_B}
   {Mando a distancia del controlador NK105 a) Cominicacion por UART del estado de la botonera b) Envío de datos del controlador al LCD por SPI}
   {fig:intervencion_mando}


\section{Envio de arvhivos por USB}

\subfigtwotwo
         {0.48}{nkhack1.png} {comentario}
         {0.48}{nkhack2.png} {comentario}
         {0.48}{nkhack3.png} {comentario}
         {0.48}{nkhack3.png} {comentario}
         {Aplicacion web desarrollada para controlar la maquina, transferir archivos, gestionar la deteccion de marcas, visualizar el trabajo a cortar en tiempo real, entre otras utilidades de configuracion.}
         {fig:nkhack}
