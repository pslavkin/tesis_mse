\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3}

En este capítulo se desglosan los bloques principales del sistema, se explica su interconexion, los criterios de diseño y los aspectos mas relevantes de cada implementación.

\section{Diseño general del sistema}

En los diagramas de bloques de la figura \ref{fig:system_blocks} se realiza la comparacion entre el sistema de conexionado original, figura \ref{fig:system_blocks0}, y modificado para el reconocimiento de marcas, figura \ref{fig:system_blocks1}.

\subfigab 
         {0.45} {system_blocks0.pdf} {Diagrama de bloques del sistema original de interconexion entre la maquina CNC y el controlador NK105 sin ninguna intervencion.} {fig:system_blocks0}
         {0.45}{system_blocks1.pdf} {Diagrama de bloques del sistema de interconexion de la maquina CNC con los bloques implementados para el reconocimiento de marcas.} {fig:system_blocks1}
         {Comparacion entre la interconexion original de la maquina CNC y luego de agregar el sistema de reconocimiento de marcas}
         {fig:system_blocks}

         En la siguiente lista se detallan las principales características de cada bloque:
         \begin{itemize}
            \item{Wi-Fi: es una red inalámbrica compartida entre los bloques ``PocketBeagle'', ``Cámara de video'' y ``Navegador web''. No requiere tener acceso a internet.}
            \item{Navegador web: se refiere a cualquier dispositivo que pueda ejecutar un navegador: ordenador personal, teléfono celular, tableta, etc.}
            \item{PocketBeagle: es la plataforma de desarrollo PocketBeagle con el agregado de una circuitería que permite intercalarse entre los bloques ``Controlador CNC'' y ``Mando a distancia''}
            \item{Maquina CNC: es el conjunto de piezas electromecánicas motorizadas para el realizar el mecanizado de piezas.}
            \item{Controlador CNC: es el dispositivo electrónico encargado de comandar los motores de la maquina CNC para generar los movimientos de corte.}
            \item{Mando a distancia: es un dispositivo electrónico cableado que se conecta al ``Controlador CNC'' y cuenta con una pantalla para visualización y un teclado para interacción con el operador de la maquina.}
            \item{Cámara de video: es el dispositivo que se monta en la maquina CNC y permite capturar las imágenes que se utilizaran para el reconocimiento de marcas. En esta implementación se utiliza la cámara de un teléfono celular, pero podría ser otra mientras permita la transmisión de video por el protocolo IP.}
         \end{itemize}


\section{Bloque PocketBeagle}

   El controlador elegido para este trabajo es muy popular y su buen desempeño es reconocido en la industria, pero no ofrece ninguna opción de interconexión excepto su mando a distancia a traves de un cable multifilar.\par

   Se estudio en detalle este cable que conecta el ``Controlador CNC'' con su ``Mando a distancia'' y se determino que tiene dos canales de comunicación, una comunicación serial UART \textit{universal asynchronous receiver-transmitter} que comunica periódicamente el estado del teclado y una interfaz SPI \textit{synchronous peripheral interface} sobre la cual se envían los datos a la pantalla LCD. \par

   Para poder interactuar con estas interfases se intercaló una tarjeta electronica que las conecta a la plataforma PocketBeagle como se muestra en la figura \ref{fig:handheld_a_pocket} .\par

\subfigab 
{0.48} {handheld_a_pocket_original} { ``Controlador CNC'' conectado con su ``Mando a distancia'' sin intervencion.\\ \vphantom{1}}{handheld_a_pocket_original}
{0.48} {handheld_a_pocket_intervenido} {``Controlador CNC'' conectado con su ``Mando a distancia'' intervenido por la\\ ``PocketBeagle''.}{handheld_a_pocket_intervenido}
   {Comparacion entre la conexion del controlador y su comando antes y despues de ser intervenido por el accesorio desarrollado.}
   {fig:handheld_a_pocket}

         Como la conexión entre el ``Mando a distancia'' y el ``Controlador NK105'' se realiza con un conector, el proceso de intercalar ``PocketBeagle'' es un proceso reversible, no modifica la funcionalidad original del sistema y permite instalarse sin dificultades.\par

   Se desarrollaron una serie de aplicaciones de software que se muestran en la figura \ref{fig:system_blocks2} para lograr dos objetivos principales que se detallan en las subsecciones siguientes

\subfiga {0.8}
         {system_blocks2.pdf}
         {Diagrama de bloques del sistema implementado con el objeto de identificar las tecnologías involucradas en cada bloque.}
         {fig:system_blocks2}

\subsection{Teclado virtual}

      Para lograr enviar datos desde la PocketBeagle al controlador se desarrollo una aplicación en lenguaje C que corre como servicio en la PocketBeagl.\par
      En el fragmento de código \ref{cod:handheld1} se pueden ver tres tareas o \textit{threads} que implementan la lectura del teclado físico, la lectura de una cola virtual, el intercalado y el envió de los datos al controlador.\par

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={Tarea encargada de procesar los datos del teclado fisico y reenviarlos a la cola de multiplexado.}]

   void* rcvFunc(void* niyto)
   {
      char frame[FRAME_SIZE];
      while(true) {
         while ( Get_Byte(PORT_NUMBER, frame )<1 || frame[0]!=FRAME_HEADER)
            ;
         PollComport(PORT_NUMBER, frame+1, FRAME_SIZE-1);
         if(memcmp(frame,FRAME_DEFAULT,FRAME_SIZE))
            mq_send(msgQueue,frame,FRAME_SIZE,1);
      }
   }
   \end{lstlisting}
\end{figure}

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={},title={\lstlistingname~\thelstlisting:Tarea que recibe datos del teclado virtual y los reenvia a la cola de multiplexado..}]
   void* rcvVirtual(void* niyto)
   {
      char buf  [ MAX_VIRTUAL_CMD_LENGHT ];
      char frame[ FRAME_SIZE             ];
      FILE* pipeVi;
      while(pipeVi=fopen(PIPE_VI,"r")) {
         while(fgets(buf,MAX_VIRTUAL_CMD_LENGHT,pipeVi)>0) {
            memcpy(frame,FRAME_DEFAULT,FRAME_SIZE);
            mapBtn2Bits(atoi(buf),frame);
            crc(frame);
            if(memcmp(frame,FRAME_DEFAULT,FRAME_SIZE)) {
               mq_send(msgQueue,frame,FRAME_SIZE,1);
            }
         }
         fclose(pipeVi);
      }
   }
   \end{lstlisting}
\end{figure}

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={},title={\lstlistingname~\thelstlisting:Taread de multiplexado de los datos del teclado fisico y virtual.}]
   void* sendFunc(void* niyto)
   {
      struct timespec tm;
      char frame[ FRAME_SIZE ];
      while ( true ) {
         clock_gettime(CLOCK_REALTIME, &tm);
         tm=timespec_add (tm,(struct timespec){0, QUEUE_SND_TOUT});
         mq_timedreceive( msgQueue,frame,FRAME_SIZE,NULL,&tm);
         sendBuf        ( PORT_NUMBER  ,ans?frame:FRAME_DEFAULT ,FRAME_SIZE );
      }
   }
   \end{lstlisting}
\end{figure}

   Se aprovecharon los mecanismos de colas o FIFO's \textit{names pipes} por sus siglas en inglés, que ofrece Linux para multiplexar los datos del ``Teclado'' con un nuevo bloque ``Teclado virtual''.\par
      Con esta tecnica, si se envian datos a la ``FIFO Rx'' los datos se envian al controlador emulando el presionado de un boton en el teclado fisico, pero al mismo tiempo se atiende la comunicacion original y el controlador se puede manejar virtual o fisicamente.\par
   Dado que la recepcion es a traves de una FIFO, es posible instanciar mas de un teclado virtual con accesos concurrentes \citep{book:embeddedprimer}.

\subsection{Pantalla virtual}

      Para poder conocer el estado del controlador es necesario contar con la informacion que se muestra en la pantalla LCD.\par
      Se estudio en detalle las especificaciones del controlador de esta pantalla y debido a la alta velocidad de los datos y que las tramas no estan definidas ni en tiempo ni en el largo de las tramas, no fue posible leer esta informacion con una aplicacion en espacio de usuario. \par
      Para poder recolectarlos se implemento un driver SPI en modo exclavo \textit{spi slave} como modulo del kernel del sistema operativo \citep{book:ldd3}.
      Este driver, a diferencia del driver original del kernel, permite recibir cualquier longitud de trama y en cualquier momento y almacenarla en una memoria contigua.
      Esto se logro utliazando las siguientes tecnicas:
      \begin{itemize}
         \item {Interrupciones: Se utilizo una interrupcion conectada a la senal de seleccion de chip del SPI \textit{chip select}. Esto permite reaccionar rapidamente cuando se inicia una transaccion.}
         \item {Acceso directo a memoria: Se utilizo el susbsistema DMA \textit{direct access memory} para que las operaciones de copia de los datos que se reciben por SPI a mamoria las realice un bloque de hardware sin la intervencion del procesador. Esto permite conservar los recursos del procesador para otras tareas.}
         \item{Comunicacion interprocessos: Se utilizaron diversos metodos de IPC's \textit{interprocess commnications} que ofrece Linux para lograr un sistema reactivo con minimo retardo.}
         \item{Operaciones de archivo: Para la salida de los datos se utiliza el acceso estandard del sistema como si este fuera un archivo. De esta manera se aprovechan las herramientas estandars de lectura del sistema operativo y se facilita la integracion con el software en espacio de usuario.}
         \item{multitarea de kernel: dentro del modulo se utilizaron varias tareas \textit{kthreads} para evitar bloqueos entre operaciones de escritura de datos al espacio de usuario con la recepcion de nuevos datos por SPI}
      \end{itemize}

      En el diagrama de bloques de la figura \ref{fig:lcd_driver_blocks} se muestra la secuencia de pasos que se implemento dentro del modulo. 
      
\subfiga {0.7}
         {lcd_driver_blocks.pdf}
         {Diagrama de bloques implementados en el driver de kernel para la lectura e interpretacion de las tramas del LCD.}
         {fig:lcd_driver_blocks}

\begin{figure}[h]
   \begin{lstlisting}[caption={Manejador de la interrupcion asociada auna transaccion SPI. Cuando es llamada activa toda la cadena de procesos que actualiza el estado de la pantalla.},label={cod:lcd_driver}]
   static irq_handler_t csIrqHandler(unsigned int irq, void *dev_id, struct pt_regs *regs)
   {
      complete(getNewDataReady());
      return (irq_handler_t) IRQ_HANDLED;
   }
   \end{lstlisting}
\end{figure}

\begin{figure}[h]
   \begin{lstlisting}[caption={},label={cod:lcd_driver},title={\lstlistingname~\thelstlisting: Tarea que espera en modo bloqueante una trama nueva. Utiliza uno de los metodos de comunicacion interprocesos del kernel de Linux.}]

   static int newDataFunc(void *nol)
   {
      int ans;
      while(1) {
         ans=wait_for_completion_interruptible_timeout(&newData.ready,msecs_to_jiffies(param_newDataTout));
         reinit_completion(&newData.ready);
         newData.actualIndex = findSpiFifoLen(newData.actualIndex);
         newData.lastIndex = parse ( newData.actualIndex);
         if(ans==0)
            wakeUpFileOp();
      }
      return 0;
   }
   \end{lstlisting}
\end{figure}

\begin{figure}[h]
   \begin{lstlisting}[name={caption},caption={},label=cod:lcd_driver,title={\lstlistingname~\thelstlisting: Funcion que bloquea a la espera de una operacion de lectura del espacio de usuario. Cuando se activa copia el estado de la pantalla.}] 

   static ssize_t lcd_read( struct file *filp, char __user *buf, size_t count, loff_t *f_pos )
   {
      size_t len=0;
      size_t miss=0;
      char localBuf[FRAME_LEN];

      int i=(int)filp->private_data;
      wait_event_interruptible(fileOp.queue[i].ready, fileOp.queue[i].flag);
      fileOp.queue[i].flag=false;
      len  = ((FRAME_LEN-1)<count)?(FRAME_LEN-1):count;
      memcpy(localBuf,(char*)getLcd()->cdram,LCD_LEN);
      snprintf(localBuf+LCD_LEN,TRAILER_LEN,"%05u\r\n",fileOp.queue[i].frameNumber++);
      miss= copy_to_user(buf,localBuf,FRAME_LEN-1);
      len=len-miss;
      decWakeUpCounter();
      return len;
   };
   \end{lstlisting}
\end{figure}

\subsection{Sistema virtual completo}
      En conjunto los dos susbsistemas, el teclado virutal corriendo como servicio del sistema operativo para manajar la UART y la pantalla virtual corriendo como modulo del kernel asociadodo a la interfaz SPI, son todo lo necesario para tomar control de la maquina desde la PocketBeagle.\par
      En la foto de la figura \ref{fig:handheld_lcd_on_action} se puede ver en la pantalla del ``Mando a distancia'' una operacion de ejemplo en la cual se ingresan los numeros ``1234'' sin presionar los botones del teclado fisico sino que se envian desde una consola de comandos de la PocketBeagle.\par
      Dada lo compelidad y la falta de informacion oficial, el desarrollo y puesta a punto de estos dos subsistemas representaron aproximadamente el 50\% del desaroollo total de este trabajo.\par

\subfiga {1}
         {handheld_lcd_on_action}
         {Virtualizacion completa del teclado y LCD utilizando la PocketBeagle. Se envian datos a una FIFO que son leidos por un servicio que los redirecciona al controlador. Los datos del LCD son capturados por el el driver de kernel y mostrados en la consola. Se puede ver la sincronia entre el mando a distancia y el virutal.}
         {fig:handheld_lcd_on_action}


\subsection{Conextion USB como almacenamiento masivo}
   Otro de los inconvenientes del controlador es que la unica manera para transferirle archivos es a traves de la conexion por USB de un dispositivo de almacenamiento masivo.\par
   Dado que la PocketBeagle cuenta con una conexion USB que puede actuar como un dispositivo de almacenamiento masivo virtual, se desarrollo una tecnica para intercambiar archivos con el controlador de manera remota a traves de Wi-Fi. \par
   La tecnologia involucrada en Linux para permitir este funcionamiento es \textit{configFS}\citep{WEBSITE:configfs}.\par.
   Se implemento un sistema de doble sistema de archivos como el que se muestra en la figura \ref{fig:configfs}.

\subfigab 
{0.48} {configfs1} {El controlador lee nuevos archivos del sistema de archivos 1 en verde. La aplicacion escribe futuros trabajos en el sistema de archivos 2 en rojo.}{fig:configfs1}
{0.48} {configfs2} {El controlador lee nuevos archivos del sistema de archivos 2 en rojo. La aplicacion escribe futuros trabajos en el sistema de archivos 1 en verde.}{fig:configfs2}
   {Sistema de doble sistema de archivos. El verde se presenta al controlador como un dispositivo de almacenamiento masivo con archivos para su ejecucion. Al mismo tiempo el rojo se presenta a la aplicacion web como un sistema de archivos para escribir archivos de futuros trabajos.}
   {fig:configfs}

   En el script mostrado en \ref{cod:configfs} se aprovecha el lenguaje \textit{bash} para implementar este sistema dual en muy pocas lineas.\par
   Este script corre como servicio en la PocketBeagl.

\begin{figure}[h]
   \begin{lstlisting}[language=bash,caption={Implementacion de doble sistema de archivos conectado con la tecnologia configFS. Se aprovecha la potencia del lenguaje de scripting y se corre como servicio.},label={cod:configfs}]

   pipe=./mass_pipe
   mnt_point=./mnt_point
   lun_file=/sys/kernel/config/usb_gadget/g_multi/functions/mass_storage.usb0/lun.0/file
   fs0=./fs0.img
   fs1=./fs1.img

   while true
   do
       if read line <$pipe; then
           if  test $fs = $fs0
           then
              fs=$fs1
           else
              fs=$fs0
           fi
           mount $fs $mnt_point
           cp  $line $mnt_point
           umount $mnt_point
           echo $fs > $lun_file
       fi
   done
   \end{lstlisting}
\end{figure}


LLEGUE HASTA ACA \ldots.

   \subsection{Camara de video a PocketBeagle}

\section{Kernel de Linux y file system}
   \subsection{Adaptacion del devicetree para PocketBeagle}
   \subsection{Manejador de dispositivo SPI esclavo}
   \subsection{Decodificacion de comandos del LCD}
\section{Aplicación de captura de teclado}
\subsection{Aplicación de rotación y escala de GCode}
\subsection{Algoritmos para reconocimiento de marcas}

\subsection{Intervencion al NK105}

\section{Intervencion al NK105}

\subfigab
         %{intervencion_mando_uart}{intervencion_mando_spi}
   {0.45}{no_signal}{comentario}{fig:intervencion_mando_A}
   {0.45}{no_signal}{comentario}{fig:intervencion_mando_B}
         {Mando a distancia del controlador NK105 a) Cominicacion por UART del estado de la botonera b) Envío de datos del controlador al LCD por SPI}
         {fig:intervencion_mando}


\section{Envio de arvhivos por USB}

\subfigtwotwo
         {0.48}{nkhack1.png} {comentario}
         {0.48}{nkhack2.png} {comentario}
         {0.48}{nkhack3.png} {comentario}
         {0.48}{nkhack3.png} {comentario}
         {Aplicacion web desarrollada para controlar la maquina, transferir archivos, gestionar la deteccion de marcas, visualizar el trabajo a cortar en tiempo real, entre otras utilidades de configuracion.}
         {fig:nkhack}
