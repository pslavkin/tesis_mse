\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3}

En este capítulo se desglosan los bloques principales del sistema, se explica su interconexión, se exponen los criterios de diseño y se destacan los aspectos mas relevantes de cada implementación.

\section{Diseño general del sistema}

En los diagramas de bloques de la figura \ref{fig:system_blocks} se realiza la comparación entre el sistema de conexionado original, figura \ref{fig:system_blocks0}, y el modificado para el reconocimiento de marcas, figura \ref{fig:system_blocks1}.

\subfigab 
{0.45} {system_blocks0.pdf} {Conexión entre la máquina CNC y el controlador sin ninguna intervención.\\ \vphantom{1}} {fig:system_blocks0}
        {0.45}{system_blocks1.pdf} {Conexión de la maquina CNC con el agregado de los bloques para el reconocimiento de marcas.} {fig:system_blocks1}
        {Comparación entre la conexión original de la máquina CNC y la modificada para el reconocimiento de marcas.}
        {fig:system_blocks}

        En la tabla \ref{tbl:descripcion_de_bloques} se detallan las principales características de cada bloque junto a una imagen del objeto físico que representa:
         \begin{longtable}[!h]{m{0.6\textwidth}p{0.3\textwidth}}
            \caption[Características de los bloques principales]{Descripción e imagen representativa de los bloques principales del sistema.}\\
            \toprule
               \textbf{Características del bloque} & \textbf{Imagen}\\ 
            \midrule
            \endfirsthead
            \caption[Características de los bloques principales. Continuación]{Descripción e imagen representativa de los bloques principales del sistema. Continuación.}\\
            \toprule
               \textbf{Características del bloque} & \textbf{Imagen}\\ 
            \midrule
            \endhead
%-----------------------------
               {Wi-Fi: es una red inalámbrica compartida entre los bloques ``PocketBeagle'', ``Cámara de video'' y ``Navegador web''. No requiere tener acceso a internet. Si la tuviera, se podría acceder al sistema también desde internet.}
               &
               \figtable{0.2}{router_wifi} \\
%-----------------------------
               {Navegador web: Es un dispositivo que puede correr un navegador web: ordenador personal, teléfono celular, tableta, etc. Sin embargo algunas características del software solo son aprovechables desde una pantalla mayor a 20''.}
               &
               \figtable{0.2}{celu_tableta_monitor} \\
%-----------------------------
               {PocketBeagle: es la plataforma de desarrollo elegida con el agregado de una circuitería que adapta las señales y permite intercalarse entre los bloques ``Controlador CNC'' y ``Mando a distancia''.}
               &
               \figtable{0.2}{pocketbeagle} \\
%-----------------------------
               {Máquina CNC: es el conjunto de piezas electromecánicas motorizadas para realizar el mecanizado de piezas.}
               &
               \figtable{0.2}{maquina_cnc_star1} \\
%-----------------------------
               {Controlador CNC: es el dispositivo electrónico encargado de comandar los motores de la maquina CNC para generar los movimientos de corte.}
               &
               \figtable{0.2}{controlador_nk105_solo} \\
%-----------------------------
               {Mando a distancia: es un dispositivo electrónico cableado que se conecta al ``Controlador CNC'', cuenta con una pantalla para visualización y un teclado para interactuar con el operador de la maquina.}
               &
               \figtable{0.2}{comando_nk105_solo} \\
%-----------------------------
               {Cámara de video: es el dispositivo que se monta en la maquina CNC y permite capturar las imágenes que se utilizarán para el reconocimiento de marcas.\par En esta implementación se utiliza la cámara de un teléfono celular, pero podría ser otra mientras permita la transmisión de video por Wi-Fi.}
               &
               \figtable{0.2}{telefono_como_camara} \\
%-----------------------------
               \bottomrule
            \label{tbl:descripcion_de_bloques}
         \end{longtable}

\section{Bloque PocketBeagle}

   El controlador elegido para este trabajo es muy popular y su buen desempeño es reconocido en la industria, pero no ofrece ninguna opción de interconexión excepto su mando a distancia a través de un cable multifilar.\par

   Se estudió en detalle este cable que conecta el ``Controlador CNC'' con su ``Mando a distancia'' y se determinó que conduce dos canales de comunicación que se detallan en la siguiente lista:
   \begin{itemize}
      \item{UART: \textit{universal asynchronous receiver-transmitter} es una comunicación serial que comunica periódicamente el estado del teclado al controlador.}
      \item{SPI: \textit{synchronous peripheral interface} es una interfaz sobre la cual se envían los datos desde el controlador a la pantalla LCD.}
   \end{itemize}

   Para poder interactuar con estas interfases se intercaló una tarjeta electronica que las conecta a la plataforma PocketBeagle. En la figura \ref{fig:handheld_a_pocket} se muestra esta conexión en comparación con la original.

\subfigab 
   {0.48} {handheld_a_pocket_original} { ``Controlador CNC'' conectado con su ``mando a distancia'' sin intervención.\\ \vphantom{1}}{handheld_a_pocket_original}
   {0.48} {handheld_a_pocket_intervenido} {``Controlador CNC'' conectado con su ``nando a distancia'' intervenido por la\\ ``PocketBeagle''.}{handheld_a_pocket_intervenido}
   {Comparación entre la conexión del controlador y su mando antes y después de ser intervenido por el accesorio desarrollado.}
   {fig:handheld_a_pocket}

         Como la conexión entre el ``mando a distancia'' y el ``controlador NK105'' se realiza con un conector, el proceso de intercalar la ``PocketBeagle'' es un proceso reversible, no modifica la funcionalidad original del sistema y permite instalarse sin dificultades.\par

   Se desarrolló una serie de aplicaciones de software que se muestran en la figura \ref{fig:system_blocks2} para lograr dos objetivos principales que se detallan en las secciones \label{subsection:teclado_virtual} y \label{subsection:pantalla_virtial}.

\subfiga {0.8}
         {system_blocks2.pdf}
         {Diagrama de bloques del sistema implementado con el objeto de identificar las tecnologías involucradas en cada bloque.}
         {fig:system_blocks2}

\subsection{Teclado virtual}
\label{subsection:teclado_virtual}

      Para lograr enviar datos desde la PocketBeagle al controlador se desarrolló una aplicación en lenguaje C que corre como servicio en la PocketBeagle.\par
      En el fragmento de código \ref{cod:handheld1} se pueden ver tres tareas o \textit{threads} que implementan: la lectura del teclado físico, la lectura de una cola virtual y el envió de los datos al controlador.\par

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={Tarea encargada de procesar los datos del teclado físico y reenviarlos a la cola de multiplexado.}]

   void* rcvFunc(void* niyto)
   {
      char frame[FRAME_SIZE];
      while(true) {
         while ( Get_Byte(PORT_NUMBER, frame )<1 || frame[0]!=FRAME_HEADER)
            ;
         PollComport(PORT_NUMBER, frame+1, FRAME_SIZE-1);
         if(memcmp(frame,FRAME_DEFAULT,FRAME_SIZE))
            mq_send(msgQueue,frame,FRAME_SIZE,1);
      }
   }
   \end{lstlisting}
\end{figure}

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={},title={\lstlistingname~\thelstlisting:Tarea que recibe datos del teclado virtual y los reenvía a la cola de multiplexado.}]
   void* rcvVirtual(void* niyto)
   {
      char buf  [ MAX_VIRTUAL_CMD_LENGHT ];
      char frame[ FRAME_SIZE             ];
      FILE* pipeVi;
      while(pipeVi=fopen(PIPE_VI,"r")) {
         while(fgets(buf,MAX_VIRTUAL_CMD_LENGHT,pipeVi)>0) {
            memcpy(frame,FRAME_DEFAULT,FRAME_SIZE);
            mapBtn2Bits(atoi(buf),frame);
            crc(frame);
            if(memcmp(frame,FRAME_DEFAULT,FRAME_SIZE)) {
               mq_send(msgQueue,frame,FRAME_SIZE,1);
            }
         }
         fclose(pipeVi);
      }
   }
   \end{lstlisting}
\end{figure}

\begin{figure}
   \begin{lstlisting}[label={cod:handheld1},caption={},title={\lstlistingname~\thelstlisting:Tarea de multiplexado de los datos del teclado físico y virtual.}]
   void* sendFunc(void* niyto)
   {
      struct timespec tm;
      char frame[ FRAME_SIZE ];
      while ( true ) {
         clock_gettime(CLOCK_REALTIME, &tm);
         tm=timespec_add (tm,(struct timespec){0, QUEUE_SND_TOUT});
         mq_timedreceive( msgQueue,frame,FRAME_SIZE,NULL,&tm);
         sendBuf        ( PORT_NUMBER  ,ans?frame:FRAME_DEFAULT ,FRAME_SIZE );
      }
   }
   \end{lstlisting}
\end{figure}

   Se aprovecharon los mecanismos de colas o FIFO's \textit{first in first out} que ofrece Linux para multiplexar los datos del ``teclado'' con un nuevo bloque: ``teclado virtual''.\par
      Con esta técnica, si se envían datos a la ``FIFO Rx'' los datos se reenvían al controlador emulando el presionado de un botón.\par
      Al mismo tiempo se responde a la comunicación del teclado original.\par
      De esta manera el controlador se puede manejar virtual o físicamente.\par
      Dado que la recepción es a través de una FIFO, es posible instanciar mas de un teclado virtual con accesos concurrentes \citep{book:embeddedprimer}.

\subsection{Pantalla virtual}

      Para poder conocer el estado del controlador es necesario contar con la información que se muestra en la pantalla LCD.\par
      Se estudió en detalle las especificaciones del controlador de esta pantalla con el objetivo de emular una pantalla virtual.\par
      Se encontró que debido a la alta velocidad de los datos y que las tramas no tienen un largo definido, no fue posible utilizar los drivers de spi del kernel y realizar esta emulación en espacio de usuario.\par
      Para poder capturar correctamente estas tramas se implementó un driver SPI en modo esclavo \textit{spi slave} como un nuevo modulo del kernel del sistema operativo \citep{book:ldd3}.
      Este driver, a diferencia del driver original, permite recibir cualquier longitud de trama, en cualquier momento y almacenarla en un espacio de memoria contigua.
      Esto se logro utilizando las siguientes técnicas:
      \begin{itemize}
         \item {Interrupciones: Se utilizó una interrupción conectada a la señal de selección de chip CS \textit{chip select}. Esto permite reaccionar rápidamente cuando se inicia una transacción.}
         \item {Acceso directo a memoria: Se utilizó el subsistema DMA \textit{direct access memory} para que las operaciones de copia de los datos que se reciben por SPI a memoria se realicen sin la intervención del procesador. Esto permite conservar los recursos del procesador para otras tareas.}
         \item{Comunicación ínter procesos: Se utilizaron diversos métodos de IPC's \textit{interprocess commnications} que ofrece Linux para lograr un sistema reactivo con mínimo retardo \citep{book:ldd3}.}
         \item{Operaciones de archivo: Para transferir las tramas decodificadas en espacio de kernel al espacio de usuario se utilizo el emulo el funcionamiento de un archivo.\\ De esta manera se aprovechan las herramientas de lectura del sistema operativo y se facilita el desarrollo y la integración con el software en espacio de usuario.}
         \item{Multitarea de kernel: dentro del moduló se utilizaron varias tareas \textit{kthreads} para evitar bloqueos entre operaciones de escritura de datos al espacio de usuario con la recepción de nuevos datos por SPI}
         \item{Indexado de memoria contigua: debido a que la escritura por DMA no permite escribir en colas circulares, se implementó un sistema de una cola lineal indexada. Esto permite poder leer y escribir sin solapamientos. Cuando está cerca del limite de utilización se reinician los índices.}
      \end{itemize}

      En el diagrama de bloques de la figura \ref{fig:lcd_driver_blocks} se muestra la secuencia de pasos implementada en el moduló.
      
\subfiga {0.7}
         {lcd_driver_blocks.pdf}
         {Diagrama de bloques implementados en el driver de kernel para la lectura e interpretación de las tramas de datos entre el controlador y el LCD.}
         {fig:lcd_driver_blocks}

\begin{figure}[h]
   \begin{lstlisting}[caption={Manejador de la interrupción asociada a una transacción SPI. Cuando es llamada activa toda la cadena de eventos que culmina con la actualizacion del estado de la pantalla.},label={cod:lcd_driver}]
   static irq_handler_t csIrqHandler(unsigned int irq, void *dev_id, struct pt_regs *regs)
   {
      complete(getNewDataReady());
      return (irq_handler_t) IRQ_HANDLED;
   }
   \end{lstlisting}
\end{figure}

\begin{figure}[h]
   \begin{lstlisting}[caption={},label={cod:lcd_driver},title={\lstlistingname~\thelstlisting: Tarea que espera en modo bloqueante una nueva trama de datos. Utiliza uno de los métodos de comunicación interprocesos del kernel de Linux.}]

   static int newDataFunc(void *nol)
   {
      int ans;
      while(1) {
         ans=wait_for_completion_interruptible_timeout(&newData.ready,msecs_to_jiffies(param_newDataTout));
         reinit_completion(&newData.ready);
         newData.actualIndex = findSpiFifoLen(newData.actualIndex);
         newData.lastIndex = parse ( newData.actualIndex);
         if(ans==0)
            wakeUpFileOp();
      }
      return 0;
   }
   \end{lstlisting}
\end{figure}

\begin{figure}[h]
   \begin{lstlisting}[name={caption},caption={},label=cod:lcd_driver,title={\lstlistingname~\thelstlisting: Función que bloquea a la espera de una operación de lectura desde el espacio de usuario. Cuando es llamada, copia la nueva informacion de la pantalla.}]
   static ssize_t lcd_read( struct file *filp, char __user *buf, size_t count, loff_t *f_pos )
   {
      size_t len=0;
      size_t miss=0;
      char localBuf[FRAME_LEN];

      int i=(int)filp->private_data;
      wait_event_interruptible(fileOp.queue[i].ready, fileOp.queue[i].flag);
      fileOp.queue[i].flag=false;
      len  = ((FRAME_LEN-1)<count)?(FRAME_LEN-1):count;
      memcpy(localBuf,(char*)getLcd()->cdram,LCD_LEN);
      snprintf(localBuf+LCD_LEN,TRAILER_LEN,"%05u\r\n",fileOp.queue[i].frameNumber++);
      miss= copy_to_user(buf,localBuf,FRAME_LEN-1);
      len=len-miss;
      decWakeUpCounter();
      return len;
   };
   \end{lstlisting}
\end{figure}

\subsection{Sistema virtual completo}
      Trabajando en conjunto, el teclado y la pantalla virtual son todo lo necesario para tomar control de la máquina desde la PocketBeagle.\par
      El teclado virtual corre como servicio del sistema operativo y se encarga de la comunicación UART.\\
      La pantalla virtual corre como módulo del kernel y atiende la interfaz SPI.\par

      En la foto de la figura \ref{fig:handheld_lcd_on_action} se puede ver en la pantalla del ``mando a distancia'' una operación de ejemplo en la cual se ingresan los números ``1234'' sin presionar los botones del teclado físico sino que se envían desde una consola de comandos de la PocketBeagle.\par
      Dada lo complejidad y la falta de información oficial, el desarrollo y puesta a punto de estos dos subsistemas representaron aproximadamente el 50\% del total del trabajo.\par

\subfiga {1}
         {handheld_lcd_on_action}
         {Control de la maquina mediante la PocketBeagle. Se envían datos a una FIFO y un servicio los direcciona al controlador. Los datos del LCD son capturados por el driver y mostrados en la consola. Se puede ver la sincronía entre el mando a distancia y el virtual.}
         {fig:handheld_lcd_on_action}


\subsection{Conexión USB como dispositivo de almacenamiento}
   Otro de los inconvenientes del controlador radica en que la única posibilidad de transferirle archivos es a través un dispositivo de almacenamiento masivo USB.\par
   La PocketBeagle cuenta con una conexión USB cliente que puede actuar como un dispositivo de almacenamiento masivo virtual.
   Sobre esta tecnología se desarrolló una técnica para intercambiar archivos con el controlador de manera remota a través de Wi-Fi.\par
   En la figura \ref{fig:conexion_usb} se puede ver el conexionado físico entre la PocketBeagle actuando como USB cliente y el controlador actuando como USB anfitrión \textit{host}.

\subfiga 
   {0.35} {hard_setup5} {La PocketBeagle se comporta como un dispositivo de almacenamiento. El controlador accede al sistema de archivos en busca de trabajos a procesar.}{fig:conexion_usb}

   La tecnología involucrada en Linux para permitir este funcionamiento es \textit{configFS}\citep{WEBSITE:configfs}.\par.
   Se implementó un sistema de intercambio de doble sistema de archivos como el que se muestra en la figura \ref{fig:configfs}.
   Con este método mientras el controlador accede a un sistema de archivos con trabajos a procesar, la PocketBeagle puede escribir en otro.
   Cuando se desea transferir un nuevo archivo al controlador, simplemente se invierten estos dos sistemas: el de lectura pasa a ser escritura y viceversa.

\subfigab 
   {0.48} {configfs1} {El controlador lee nuevos archivos del sistema de archivos 1 en verde. La aplicación escribe futuros trabajos en el sistema de archivos 2 en rojo.}{fig:configfs1}
   {0.48} {configfs2} {El controlador lee nuevos archivos del sistema de archivos 2 en rojo. La aplicación escribe futuros trabajos en el sistema de archivos 1 en verde.}{fig:configfs2}
   {Doble sistema de archivos. El verde se presenta al controlador como un dispositivo de almacenamiento masivo con archivos para ejecutar. El rojo se presenta a la aplicación como un sistema de archivos para escribir futuros trabajos.}
   {fig:configfs}

   En el script mostrado en el listado \ref{cod:configfs} se aprovecha el lenguaje \textit{bash} para implementar este sistema dual en muy pocas lineas.\par
   Este script corre como servicio en la PocketBeagle.

\begin{figure}[h]
   \begin{lstlisting}[language=bash,caption={Implementación de doble sistema de archivos conectado con la tecnología configFS. Se aprovecha la potencia de \textit{bash} y se corre como servicio.},label={cod:configfs}]
   pipe=./mass_pipe
   mnt_point=./mnt_point
   lun_file=/sys/kernel/config/usb_gadget/g_multi/functions/mass_storage.usb0/lun.0/file
   fs0=./fs0.img
   fs1=./fs1.img

   while true
   do
       if read line <$pipe; then
           if  test $fs = $fs0
           then
              fs=$fs1
           else
              fs=$fs0
           fi
           mount $fs $mnt_point
           cp  $line $mnt_point
           umount $mnt_point
           echo $fs > $lun_file
       fi
   done
   \end{lstlisting}
\end{figure}


\section{Cámara de video a PocketBeagle}
Como se comentó en la sección \ref{subsection:camara_de_video}, en el alcance de este trabajo se optó por usar la cámara de un teléfono celular montado en la máquina CNC y transmitir video por Wi-Fi con una paliación.\par
   En la figura \ref{fig:soporte_celu} se muestra un soporte desarrollado para sujetar el teléfono al eje Z de la máquina. \par
   Además se agregó un soporte para un puntero laser que sirve para ajustar las posiciones relativas del teléfono y el motor de corte\par
   El dispositivo de sujeción permite ajustar la altura y rotación y permite un ajuste preciso.\par

\subfigab 
{0.48} {soporte_celu1} {Soporte de teléfono implementado, con posibilidad de ajustar la altura, rotación e inclinación} {fig:soporte_celu1}
      {0.48} {soporte_celu2} {Vista superior de la maquina CNC con el soporte del celular y laser instalados.}{fig:soporte_celu2}
      {Soporte de celular y puntero laser solidarios al eje Z.}
      {fig:soporte_celu}

      Para recibir las tramas de video desde el celular y posteriormente procesarlas en la PocketBeagle, se implementó una serie de funciones en lenguaje Python sobre la base de la biblioteca PyOpenCV\footnote{\pyopencvlink}\par
   En el fragmento de código \ref{cod:reconocimiento1} se lista el procedimiento para acceder a la cámara y tomar un fotograma de video.\par

\begin{figure}[h]
   \begin{lstlisting}[language=python,caption={Conexión a la cámara del teléfono por Wi-Fi y captura de un fotograma para su posterior procesamiento.},label={cod:reconocimiento1}]
   def capture():
      vcap      = cv.VideoCapture("192.168.1.30:/video",cv.CAP_FFMPEG);
      ret       = vcap.grab()
      ret,frame = vcap.retrieve()
      vcap.release()
      return frame
   \end{lstlisting}
\end{figure}

Una vez capturado el fotograma se lo procesa con una secuencia de operaciones que se muestran en el fragmento de código \ref{cod:reconocimiento2}.

\begin{figure}[h]
   \begin{lstlisting}[language=python,caption={Algoritmo principal de reconocimiento de marcas en un fotograma},label={cod:reconocimiento2}]
def recognition(self,img):
      imgray              = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
      ret, thresh         = cv.threshold(imgray, int(self.grayThresh), 0xff, cv.THRESH_BINARY_INV)
      contours, hierarchy = cv.findContours(thresh, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)

      validContours         = 0
      maxArea               = 0
      maxAreaIndex          = 0
      maxHull               = 0
      maxRect               = 0
      height,width,channels = img.shape

      for i in range ( min(len(contours),10)):
          hull = cv.approxPolyDP(contours[i],0,True) 
          rect = cv.minAreaRect ( hull )
          area = rect[1][0]*rect[1][1]
          if ( area<targetArea*1.5 and area>targetArea*0.5 ):
              if ( area>=maxArea ):
                  maxArea      = area;
                  maxAreaIndex = i;
                  maxHull      = hull
                  maxRect      = rect
          center     = maxRect[0]
          self.angle = maxRect[2]
   \end{lstlisting}
\end{figure}

En la línea 2 del algoritmo se convierte el formato del fotograma ``img'' de tres canales azul, verde y rojo, BGR \textit{blue,green,red} de 8bits por pixel por canal a escala de grises de 8bits por pixel según la ecuación \ref{eq:bgr2gray}:
\begin{equation}
   \text{RGB[A] to Gray:} \quad Y \leftarrow 0.299 \cdot R + 0.587 \cdot G + 0.114 \cdot B
   \label{eq:bgr2gray}
\end{equation}

  Luego en la linea 3 se convierte el formato de escala de grises a binaria de 8bits, en dónde el criterio de selección por 0 o 255 lo decide la variable grayThresh.\par
  Un ejemplo de esta secuencia de procesamiento se puede ver en la figura \ref{fig:reconocimiento_paso_a_paso1}.

\subfigabc
         {0.3}{reconocimiento_paso_a_paso1} {Imagen original en color BGR.}{fig:reconocimiento_paso_a_paso1a}
         {0.3}{reconocimiento_paso_a_paso2} {Imagen escala de grises.}{fig:reconocimiento_paso_a_paso1b}
         {0.3}{reconocimiento_paso_a_paso3} {Imagen binaria.}{fig:reconocimiento_paso_a_paso1c}
         {Imagen original, escala de grises y binaria obtenidas mediante un algoritmo en python como parte del proceso de reconocimiento de marcas.}
         {fig:reconocimiento_paso_a_paso1}

         La imagen binaria es procesada en la línea 4 por la función ``findContours'' \footnote\opencvfindcontours ,que busca todos los posibles contornos.\par
         Sin embargo esta parametrizada para que retorne solo aquellos que no están encerrados por un contorno mayor.\par
         En el ejemplo de la figura \ref{fig:reconocimiento_paso_a_paso2b} se puede ver que los cuadrados sin relleno son detectados solo por su contorno externo.\par
   En la siguiente parte del algoritmo se recorren todos los contornos encontrados y se le aplica una función que aproxima cada contorno a uno mas suave.\par
   Este algoritmo pretende filtrar irregularidades de la marca o de la captura de video y se configura para que devuelva siempre un perímetro cerrado.\par
   Se utiliza la función minAreaRect en la linea 15 para encontrar un rectángulo de area mínima que encierre completamente al perímetro.\par
   Esto permite calcular una buena aproximación del área y del anguló.\par
   Con esta información se selecciona solamente el perímetro que tenga una área cercana a la especificada por el parámetro ``targetArea''. \par
   Esto permite al usuario discriminar una marca por sobre otras.\par
   Finalmente a la marca elegida se le calcula el desplazamiento en X e Y y su rotación respecto a la cámara.\par
   Estos son los datos que se ingresan en las ecuaciones trigonométricas vistas en la sección \ref{subsection:trigonometria} y es lo que permite realizar la alineación de la pieza.\par
  La secuencia de pasos mencionada se puede ver en la figura \ref{fig:reconocimiento_paso_a_paso2}.

\subfigabc
         {0.3}{reconocimiento_paso_a_paso4} {Imagen binaria con todos los perímetros encontrados.}{fig:reconocimiento_paso_a_paso2a}
         {0.3}{reconocimiento_paso_a_paso5} {Imagen con los perímetros encerrados por rectángulos de área mínima.}{fig:reconocimiento_paso_a_paso2b}
         {0.3}{reconocimiento_paso_a_paso6} {Discriminación de la marca deseada utilizando el área como selector.}{fig:reconocimiento_paso_a_paso2c}
         {Proceso de filtrado y selección de perímetros dentro de la imagen. Como resultado se obtiene el centro y rotación de la marca con el area especificada.}
         {fig:reconocimiento_paso_a_paso2}

         En el apéndice \ref{AppendixA} se presentan mas ejemplos de capturas de marcas mas complejas en donde se visualizan todos los pasos del algoritmo.\par

